
### CodeM2018 初赛B轮 T5
定义函数
$$
\begin{equation}
f(l, r)=\left\{
\begin{aligned}
0, & & l \ge r,\\
f(l, r - lowbit(r)) + 1, & & l \le r - lowbit(r), \\
f(l, r - 1) + 1, & & r-lowbit(r) \lt l \lt r.
\end{aligned}
\right.
\end{equation}
$$
给出n，对$\forall 0\le l \le r \le n$，求$f(l, r)$的最大值
n可以非常大，给出n的方式是输入一个长度不超过$2\times 10^4$的01串，代表n的二进制表示。

-----

我们看看结论要怎么分析出来。
f函数的递推过程用语言表示，就是固定l，把r一点点减小，直到l=r。其中，要么-1，要么去掉r的二进制最低位1。
如果$ l \gt r - lowbit(r)$，会发生什么？
```
l:      xxx0nnnnnnnn
r:      xxx100000000
r-1:    xxx011111111
        xxx011111110
        xxx011111100
        xxx011111000
        ...
        xxx010000000
        
        xxx001111111
        xxx001111110
        xxx001111100
        ...
        xxx001000000
```

描述r减小的过程。
r减小到什么时候为止？
如何让r减少的次数最多？既然对l没什么限制，贪心，nnnnnnnn部分是00000001。此时r减小多少次，这是一个什么问题，怎么计算？

xxx是什么？这个前缀是没有意义的，我们把这个前缀去掉，l和r肯定更满足<=n。
这样l就是1了。这么一来我们得到了什么结论？？

`结论`
对于n=1，答案是f(0, 1)=1，对于n&gt;1，一定存在最大的f(l, r)，满足l=1。

那么r怎么选择？基本上越大越好，但也不全是。
举个例子，n=12，1100，l=1，那如果r=1100，则f=7，如果r=1011，则f=8。

设n为
```
100...01xxxxxxxxxx
```
则在r中，我们的最高位肯定要保留，为什么？
那么，一开始的若干次r的减小，肯定最后让r变成：
```
100...000000000000
```
也就是全是lowbit。
我们还有这里的优化空间，原则是让r除了最高位以外1的个数最多。

如果我们放弃次高位，可以让xxx...x全是1，这已经是一个不错的解了。只有当一开始xxx..x就全是1时，才可能比它优。

所以我们的代码流程：
找到最高位
找到其余位1的个数的最大值：

-    判断是否是特殊情况
-    放弃次高位

计算两部分答案加起来，输出。

----

### tcsrm588-3 GameInDarknessDiv1
给一棵树，两个人在两个不一样的节点上，轮流移动，A先走，每次必须走到一个相邻的格子上（不能不动），A在一开始需要公布自己的移动方案。如果A和B走到了一个点上则算A赢，如果B走了10W步都没输则算B赢，问A有没有必胜策略。点数<=2500

----

原题是给一个网格图，上面的非坏点构成一棵树，没啥用。原题的题意是，游戏在黑暗环境进行，A不知道B在怎么走，而B能预见到A会怎么走。等价。

什么是这道题合理的思考模式？
我们不把B看作一个点，而是看作一个点集，代表这个时刻B所有可能处在的位置。每一步A走到的点，都会从这个点集中扣去，而A每走完一步，点集都会变换一次，实现B的可能性的扩展。这样，我们的目的就是制定A的走路方案，最终目的是让B的点集变成空集。如果我们做不到这一点，很容易通过每一步的点集的变化找到B的一条逃生路线。

开始游戏后，A肯定要往B的方向走，因为A如果不这么走，只会让他回来的时候B的可能位置增多，赢的能力严格小。A沿途的路径上，一开始是一段B在当前步数内走不到的点，这些点不用管，直到A走到一个分岔口，其中B有可能在其中之一的内部。如果走到一个岔口的子树的深度<=2，也就是最多形如
分岔口A--X--Y1
        |
        Y2,...
类似的形式，则这子树可以直接A->X->A验证完毕，证明分类讨论，如果在这个子树里，如果在X上，一步搞定，如果在Y上，则A走到X之后B只能走X，然后搞定。这个情况有个好处，就是如果不在这个子树里，在别的子树里，仅仅这两步操作是不够B换到别的子树去的，还得堵在原来的位置里。
但是如果深度>=3就不好说了。必须深入检查。深入检查带来的后果，就是B可以借助这个空隙换树。如果这个分岔口只有这一个不满足要求的，则走下去检查完再走上来，时刻维护着走过的不可能再有B，就好了。如果有两个，可以走一个下去，再走上来，再走下去另一个，也跑不掉。但是如果有三个，一开始可能在两个里，则走一个下去再走上来，还是可能在两个里，于是永远确定不了B的位置。
如果B没办法达成这样的情况，则A肯定能在常数次对树的扫描里解决B，否则，B就去达到这个情况，想走几步走几步。
B达到这个情况的方法，就是找到一个三岔口，且在A走到这个岔口时，有办法让自己同时有可能在至少两个合法子树里。设这个口是u，则B必须要走到u，否则就只可能在一个子树里，分析无效。而为了让A走到这个口时已经部署完毕，则需满足dis(A,u)>=dis(B,u)+c，c是个常数，不能是0，不能是1（因为A先走）所以就是2了。
复杂度O(n^2)。

-----

### tcsrm593-3 WolfDelaymasterHard
给一个含有w,o,?三个字符的串，把?替换成w或o，使得结果串可以分割成若干部分，每部分都是'w'*n+'o'*n(www..wooo..o)，w和o个数相同，的形式。求方案数。|s|<=2,000,000

----

分两种情况，前半部分只有'?'或者前半部分除了'?'还有'w'，第一部分对于一个j，满足条件的i是一个区间，第二部分对于一个i，满足条件的j是一个区间。强行拆成这两部分之后，居然都能解决...原来没有连续性，是因为，从i，对于一个o，可以选择不管，还可以选择把它括进第二部分，于是就有好多区间了；从j，同理有w，也GG。但如果把情况分成两种，则这两个方向一个可以解决一种，就ok了...复杂度也是O(n)。

----

### tcsrm594-3 FoxAndAvatar
n个文件排在windows的资源管理器里，有w列，从左到右，从上到下，第x个是想要的，每次可以框选一个矩形区域删除（区域不要求是满的）,剩下的重排，问最少的删除次数达到只留下想要的那份文件的效果。n,w<=3000

-----

答案最多是4，方案很好构造。
如果我们能够判断0~3，则就解决了。
如果我们能O(1)判断1，则只需枚举两步的走法即可。
无论x在什么位置，x之后的越少，删完x之后的还需要的次数就越小。所以，我们要尽量多删x之后的。框选的矩形只有可能是x上方的子矩形，x左、右的子矩形，或者x下边的整个矩形。如果我们能把枚举降到O(n)，则两步我们都暴力枚举即可。
对于删上面的，我们只关心删掉的个数，所以O(n)枚举个数。可以预处理一个mxd[i][j]表示i的最大的<=j的约数，用来判断是否可行。
对于删左边和右边的，如果我们只看x之前的选择，则这些选择是个矩形，枚举这个矩形的大小，选择这个矩形最大可能的宽，这个矩形肯定顶着整个图形的底（为了删掉尽量多的x后文件）总的是O(n)的。
另一种O(n)枚举左右的方法：左边枚举左上角，右侧靠ｘ，右边枚举右上角，左侧靠ｘ，O(n)。
对于删下面的，只有一种情况。
所以总复杂度O(n^2)。

-----

### tcsrm596-3 SparseFactorial
定义函数F(n)=\prod_(0<=i<=ceil(sqrt(n - 1))) (n-i^2)    也就是枚举到最大的i满足n-i^2>0。 求[l,r]中有多少个n使得d|f(n)，l,r<=10^12,d<=10^6

-----

对于%d相同的一类n，如果d|f(n)，则d|f(n+d)，所以此时如果对于每个剩余系求出第一个能满足要求的位置，则查询[1,n]，只需枚举模的结果，然后算一算在这之中的有几个就好了。
然后我们就枚举n%d=i，如果我们想验证x是否合法，就要算一下F(x)，也就是枚举x-k0^2,x-k1^2,x-k2^2,...，每次把x-kj^2中含有的d中的因子拿过来，直到kj已经超出了可用范围，或者已经足够凑出d了为止。注意到x-kj^2含有的因子只和j有关而不和x有关，因为x变成x+d，d的因子部分没变，变的部分我们用不到，所以其实只需看最少用几个kj^2，于是枚举kj^2。不过这样是带一个sqrt的。再次注意到，我们只需把每个质因子的次数凑够，总的次数是很小的(log)，如果我们只枚举会更新的kj，就快多了。于是我们把kj^2按照每个质因子的余数分类存，每次在里面单调扫。复杂度dlog^2d，
继续优化其实很简单，把每个质因子幂的答案单独算出来，取max就行了。

-----
### tcsrm597-3 LittleElephantAndBoard
2\*M的矩形，用RGB三种颜色染，三种颜色的个数全部给定，有公共边的格子不同色，每个2\*2的连续子矩形拥有全部的三种颜色。求染色方案数。M<=10^6

-----
确定了第一行，满足第一行没有相邻同色后，枚举第二行第一个格子的两种染法，往右推下去，每个后面的格子有确定的染法，所以只需填好第一行，方案数*2。进一步发现第二行每个颜色的个数实际是第一行个数循环移位了一下，则第一行可以转化成填M-R,M-G,M-B个R,G,B，题解的解释更不错，我们用一列没出现过的颜色当做第三列，则相当于填第三列，第三列的每个元素就是M-(R,G,B)个。
如何算填R,G,B使得同色不相邻的方案数？先把R放进来，有R-1个空位要求之后用G,B完全打散。枚举前后有没有多放，转化成三个形如把G,B填到R个位置使得其中没有空缺且每个位置里GB自己不会同色相邻。每段都形如GBGB,BGBG,GBGBG,BGBGB四种情况，枚举第三种，可以算出第四种，以及前两种的和，前两种可以看做同一种，最后要乘以2^前两种。前两种先每个需要一个GB，扣掉这些需求后，变成了把{BG}这个整体插入R个空位中，这是组合数问题，于是就解决了。没有看出前两种可以同等对待，所以没推出来。复杂度O(M)
有一个更简单的计数办法：枚举G被分成了几堆，算组合数，枚举前后放不放，插入R，可以计算出现在RR相邻或者GG相邻一共有多少对，然后用单个的B插入解决即可。复杂度O(M)

------

### codem2017复赛 排列
给出两个1...n的排列组成n对点，要求出有多少种这些点的排列顺序，满足执行以下算法后最后剩下的点是原来给出的第x个。对1<=x<=n都要求解。数据范围：n<=10^5
题面给出的算法：令初始答案为第一个点，从第二个点扫到第n个，如果新的点的两维都严格大于当前答案，则把当前答案更新成新的点，算法的执行结果为最后的答案。

-----

对于一个最后答案的更新序列(p1,p2,...,pk)，在pk停止，尝试表示它的方案数。
对于不在更新序列里的点，不能出现在序列中，所以，它要满足放置的位置在序列里第一个存在任意一维大于他的位置之后。如果序列里没有这个位置，则答案为0，发现有答案当且仅当没有任何一个点两维都大于pk。剩下的限制就变成了，限制了ai个点必须在pi的后面，这些限制构成了一条链。ai的值，就是两维大于p(i-1)的点数。这样的序列方案数是n!/πai，这个可以从单个的情况猜测，也可以用一个归纳法证明，还可以从大到小考虑得出。
然后我们发现我们可以用DP来计算出所有更新序列的∑1/πai，因为这个贡献是可以拆开并对应到每个选点上的。排序一维，另一位数据结构，复杂度O(nlogn)。

![](/api/file/getImage?fileId=5b31d7f88298cf03a5000007)

------


### bzoj1604 [Usaco2008 Open]Cow Neighborhoods 奶牛的邻居
n个二维平面上的点，两个点之间连边当且仅当两点的曼哈顿距离<=c，问最后的连通块个数和最大连通块大小。n<=10w

------

转成切比雪夫距离。变成在相邻的一个正方形内连边。
按横坐标从小到大枚举点，之前的点保留横坐标在合法区域的即可，在这些点里把纵坐标满足要求的点都连上，但是复杂度仍然不对。改进方法，注意到合法区域内的任意两点横坐标都肯定满足要求，纵坐标在当前点之上的第一个点暴力连上，更靠上的点如果能到当前点就一定能到第一个点，不必再连，在当前点之下的同理，动态增删，前驱后继，set。
复杂度O(nlogn)