20180330小测

你说我怎么这么菜呢?
请看我直播把260分扔成120分......

T1:
题目就是给你个trie，在trie的每个节点上存在一些点，我们要询问这些点中权值最大的一些。
炸胡题，我们直接在节点上开vector把那些点都push进去就好了......
这不像后缀自动机会卡n^2，这个东西由于有输入数据长度限制所以不会。
于是我写了线段树。虽然不好写吧，但是也不应该爆零啊。
注意输出描述的最后一句，行末不应有空格。也就是说，这题卡行末空格！于是我就华丽爆零了。
(自己不看题还能怪谁?)
考场爆零代码:
考后AC代码:

T2:
我们可以f[i][0/1]点i及以后是否去掉边，然后枚举是在下一层及以后去还是现在这层去，胡乱转移就好。
恭喜你，这样是不对的。
详见下面的图:

于是你就被愉悦地WA掉了......
然后我就赶紧交了暴力......
事实证明这么写有60分，而暴力只有20分......
正解是:f[i]表示i之后期望步数，p[i]表示从0能到i的期望，g[i]表示扔掉一条i的出边，能获得的最大期望步数。
答案就是f[1]+max{0,(g[i]-f[i])*p[i]}。看起来很有道理的样子。
注意这题写正解的时候不要写记忆化搜索，否则有些点无法从0到达，他们的出边却计算了度数，这样会导致有些点永远无法被访问到。
所以我们需要从所有没有入度的点开始拓扑排序转移。
60分胡乱DP代码:
正解代码:

T3:
我告诉你我考场上唯一AC的题是这题你敢信?
我们考虑大力DP。
首先重新定义代价为:1e13*选择数量-(总高度+总补偿)。这样我们只需要一个long long就能维护。
然后重新定义高度为heighti - i，这样我们能选择高度相同的点，同时可以把无论如何也不会被选择的点扔掉(这样他们的高度<0)。
之后就是转移，我们枚举i前面的被选择的点j，我们要满足的东西有:hj<=hi。
考虑我们再次选择一个点会产生怎样的代价，显然最终的答案一定是一个阶梯状的东西，所以我们选择了i之后之后所有点的高度相对于仅选择j都会上升(hi-hj)。
于是我们就可以转移了，fi=max{fj+(hi-hj)*(n-i+1)}(hj<=hi)+cost[i]，cost[i]为单点价值减去选i的补偿代价。于是你可以写对拍用的n^2暴力了。
仔细观察这个转移方程，显然是一个可斜率优化的方程，我们可以把hi当成x，把fi当成j，把(n-i+1)当成a，把1当成b，这样最优答案就是ax+by的形式了。
因为hi不满足单调性，所以我们需要set维护凸包
考虑到我们还有hj<=hi的限制，所以需要再套一层cdq分治......
(您可写着去.jpg)
于是我花了接进1h写完代码后开始对拍，一开始出了一个很愚蠢的错误改了没事了，小数据瞬间安静，几万组都没事。
然后开始对拍5000的大数据，拍了200+组，WA了。
woc这可怎么调啊.....
又回去拍小数据，没错......
接着拍大数据，还是WA......
然后花了2个小时死活调不出来，硬着头皮交了，竟然A了......
这个故事启示我们只要小数据稳定，大数据能过几百组就别管了QAQ。
代码:

既然我这么菜还只会扔分，省选退役稳了......
不，不用等到省选，我大概已经可以滚粗学高考了吧......
