北京集训:20180326

爆零蒟蒻今天终于滚粗了......
也就是说，这是北京集训的最后一篇题解了。之后的比赛，我已经没有访问权限了。


T1:
考虑一个暴力做法:f[i][j]表示字符串区间[i,j]的最大等级。
如果k级字符串[i,j]包含一个k-1级字符串s，且s没有达到[i,j]的首(或者尾)的话，我们去掉[i,j]的首(或者尾)，剩下的仍然是一个k级字符串。
所以我们可以暴力dp，f[i][j]=max(f[i+1][j],f[i][j-1],max(f[substr])+1)。
而后面的那个可以用后缀自动机枚举出现两次及以上的子串，总复杂度O(n^3)。
显然这并不是正解(然而这对正解有很大的帮助)(要不然我也不会写他)。
考虑我们这样增量(减量?不!)去掉首尾字符的过程，我们一定能保证一个k级字符串的首尾都是一个k-1级字符串。
尾相同的子串有怎样的性质呢?他会出现在当前串的parent树的祖先上。
于是我们可以用f[i]表示后缀自动机第i个节点及其祖先节点中，最大的等级，g[i]表示取到这个等级，所在的最短的节点。
为什么这样做正确?因为对于结尾更靠后的串，我们不计算他的贡献也没有关系是吧，反正他能转移到的串的子串一定能由一个结尾更靠前的串转移到。
转移显然用最短的节点转移最优。我们暴力找头上的那个串出现的位置，看看是否可行即可。
这样我们get到了n^2暴力......
考虑我们现在复杂度的瓶颈在哪里?维护right集合和查询的过程。于是我们可以反向建立主席树并进行启发式合并，复杂度O(nlogn)。
(其实我感觉这东西时间和空间复杂度都是O(nlog^2n)的，只不过跑不满罢了)
代码:

T2:
显然不管是不是DAG，直接跑最小割都是WA的，不服见下图。
另外显然环上的边是一定不能割的，否则绕环一圈再走的路径上会有两条被割掉的边，我们可以先tarjan大力缩环变成DAG。
考虑如何防止一条路径上的边被割多次，我们能让这条路径上所有靠后的点向靠前的点连边容量inf，如果割掉后面的边且割掉前面的边相当于没割......
这建图点数O(n)，边数O(m^2)。
考虑怎么优化，由于inf具有传递性，所以我们让每个靠后的点单独向前面的点连边就行了，也就是，对于每一条边连接容量inf的反向边。
对于环的话，由于inf边的存在，我们显然不会割环上的边，于是连tarjan也省了。
然而这样是不行的，对于不在1~n路径上的边，不能连inf边，否则跑出的答案会比正确答案大(反例见上图)。
关于无解，直接判断最小割是否为inf就好了。
代码:

T3:
直接放官方题解吧......
代码:

再有十几天就省选了，我这么弱，九成是要退役了吧。
大概无论如何也不会坚持了吧。“你学下去”，想像BE里的红一样用生命挽救别人，然而还有谁值得我这样做呢？
直到现在才发现，看起来很正常的我，其实是黑的......
