51Nod1577 异或凑数 线性基 构造

国际惯例的题面:

异或凑出一个数，显然是线性基了。
显然我们能把区间[l,r]的数全都扔进一个线性基，然后试着插入w，如果能插入，则说明w不能被这些数线性表出，那么就要输出"NO"了。
然而怎么得到这个线性基？我们有两种很显然的暴力:线段树和单调莫队。然而亲测它们都不能AC......(不排除我写丑了)
考虑思考一下性质:如果我们能对于每个结束位置，用这个位置前面尽可能靠后的数构造出一个线性基，那么我们查询的时候是不是就能取出结束位置为r的线性基限制用的数出现位置不能早于l，然后直接查询就好了呢？(这种思想在Bzoj3514: Codechef MARCH14 GERALD07加强版)中也用到过。
好，如果这样做的话，怎么从结束位置为i-1的线性基得到结束位置为i的线性基呢？
我们可以把结束位置为i-1的线性基拆了，然后贪心按照出现位置从大到小插入，正确性显然，复杂度O(900n)。
查询的时候怎么办？我们把结束位置为r的线性基中出现位置>l的数拆出来，插入一个新线性基，进行查询，复杂度O(900q)。
非常不幸的是，这样仍然不能AC。虽然我已经千方百计卡常数了。
我们现在在维护出现最晚的线性无关的30个数，考虑我们维护序列最大的30个数怎么维护。
只有30个数，我们再写个堆(priority_queue？假装你是Pascal党好了)什么的显然不必要了。直接在插入的时候从大到小进行一轮冒泡排序，用当前的大数替换小数就好。
对于这个线性基，我们也能这样做。
我们从高位向低位扫描这个线性基，如果我们当前的数能被放入某个位置的话，如果这个位置为空，则直接放入；否则比较出现位置，如果当前数出现较为靠后的话，则把当前数和这个位置的数swap一下，然后从下一位继续进行插入。
然后我们会发现这样构造的线性基还会有另一个更好的性质：高位上的数出现尽量靠后。
查询的时候，从高位到低位进行查询。如果凑出w需要高位的某个数而这个数出现位置<l，那么这一位无论如何都消不掉了，直接输出'NO'即可。
这样我们就把复杂度优化为了O(30n+30q)，能够轻松AC。

暴力线段树代码:

暴力重构线性基:

正解代码:


明けの星が
启明的星辰
光を見せた
洒下丝丝光芒
よわい よわい
微微地 微微地
こころに降りそそぐ
纷纷洒落到我心房

でも時は
可有的时候
おなじ想いだけを
如果能够继续
あ…描き続ければ
描绘同样的思念…

誰も知
谁也不知道
日が射すまでに
直到太阳升起
そっと そっと
静静地 静静地
予感を感じてた
我感觉到一丝预感
こころが感じてた
我的心 有了一丝预感

特殊线性基的奇怪用法

